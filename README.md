# EJDbg
Windows and Linux Debugger FrontEnd for cdb and gdb




## 0. 개요
  디버거의 경우 플랫폼 별로 따로 존재할 수 밖에 없으며 운영체제에서 기본적으로 제공되는 디버거의 경우에는 사용하기 불편한 경우가 많아 다른 여러 종류의 디버거가 존재하며 계속 생기고 있다. 개인적으로 이런 환경은 비효율적이라고 생각하며 가장 효율적인 방법은 원하는 것을 스스로 만드는 것이라고 생각했다. 하지만 현실적으로 봤을 때 혼자서 Windbg나 Gdb 같은 운영체제에서 제공되는 디버거의 기능을 따라잡기도 힘들며, 동시에 여러 오픈 소스 디버거들 처럼 사용자 친화적인 인터페이스를 만들기도 힘들다고 생각하였다. 결론적으로 최선의 방법을 선택해서 적어도 내가 사용할만한 디버거 환경을 만드려는 목적으로 개발하게 되었다.




## 1. Windows
### 1.1 설치 및 환경
#### 1.1.1 기본 환경
- WDK 등을 통해 Windbg가 설치되어 있어야 한다. 참고로 여기서는 CLI 도구인 cdb.exe를 사용한다.
- 필요 시 환경 변수에 등록한다. 개인적으로는 실행 파일이 x86인지 x64인지에 따라 [ 환경변수 - 시스템 변수 - Path ]에 버전에 맞는 폴더 경로를 추가한다. 이를 통해 cdb.exe 명령으로 cmd.exe에서 사용 가능하다. 아니면 cdb.exe의 경로를 직접 입력할 수도 있다.
- 파이썬은 버전3을 사용하였다. 그리고 버전에 맞는 PyWin32와 WinPexpect를 설치한다.
- 로컬에서 API 관련 정보를 보고싶은 경우에는 [ 참고1 ]을 참고하여 도움말 파일을 설치한다.

#### 1.1.2 사용
  명령 프롬프트에서 해당 파이썬 스크립트를 실행하며 인자로 실행 파일을 준다.
 > python cdb_x86.py hello.exe <br>
 > python cdb_x64.py hello.exe


### 1.2 기능
#### 1.2.1 기본 기능
  스크린샷과 같이 왼쪽 윈도우에서 레지스터, 디스어셈블리, 스택을 보여주며 커맨드 라인 방식을 사용한다. 오른쪽 윈도우는 명령어의 결과를 보여준다. 그리고 아랫 부분은 디스어셈블리 창에서 보여지는 API 함수가 보여진다. 이것을 클릭하면 도움말 파일을 통해 해당 함수에 대한 정보를 볼 수 있다. [ 참고1 ]<br>
  레지스터 패널의 경우 해당 값에 대한 da @reg 명령어를 수행하여 문자열 정보도 보여준다. 디스어셈블리 패널의 경우 뒤에서 후술할 자체 명령어에서 사용될 라인 번호가 있다. 그리고 IAT 정보를 조회하여 OllyDbg처럼 API 함수를 보여준다. 원래 Windbg에서는 해당 라인에 가기 전까지는 API 함수 정보를 보여주지 않는다. 또한 jmp를 이용한 간접 호출의 경우에도 API 함수 이름을 보여준다. 스택의 경우 기본적인 심볼 정보(dds esp, dqs rsp)와 해당 값에 대한 문자열(dda @esp, dqa @rsp)를 보여준다. 마지막으로 이전 명령어를 또 실행할 때에는 그냥 엔터를 입력하면 된다.

#### 1.2.2 자체 명령어
- ,bp [ 라인 번호 ] : 인자로 직접 주소를 입력할 필요 없이 해당 라인 번호를 받아서 bp를 설정할 수 있다.
- ,wt [ 라인 번호 ] : 인자로 직접 주소를 입력할 필요 없이 해당 라인 번호를 받아서 거기까지 실행시켜 준다. wt 명령어를 이용한다.
- ,api [ api 함수 이름 ] : api 함수 이름을 직접 클릭한 것처럼 인자로 api 함수를 받아서 해당 도움말 파일을 보여준다.
- ,v : 왼쪽 윈도우 업데이트. ip 레지스터 수정 또는 변경 사항 발생 시 왼쪽 윈도우를 업데이트 해준다.
- ,c : 오른쪽 명령어 패널을 clear한다.
- ,vs <address> | ,vs u | ,vs d : 인자로 주소를 넣은 경우 왼쪽 윈도우를 그 주소에 맞게 보여준다. u와 d를 인자로 넣은 경우 각각 윗 페이지 그리고 아래 페이지를 보여준다. 굳이 u와 ub 명령어가 있는데도 구현한 이유는 그 명령어들은 API 함수 이름을 보여주지 않기 때문이다.


### 1.3 개선 사항
#### 공통
- 실행 중인 프로세스 Attach 기능 추가 (프롬프트 문제)
- 커널 디버깅 기능 추가
- scanf 같이 입력을 받는 기능도 추가한다.

#### 개별
- OllyDbg처럼 스택과 디스어셈블리 창에 API 함수의 인자를 보여줄 필요가 있다.
- 또한 사용되는 윈도우 상수들 정보도 도움이 많이 된다.
- 스택 창에 예외 핸들러도 표시되지 않는다.
- 디스어셈블리 창의 문자열을 보여주는 기능.
- 섹션 BP 기능을 생각해보자.
- a 명령어 처리.
- 모듈 이동 시 findiat() 함수가 너무 느리무로 개선한다.
- Optional Header의 "Import Address Table" Directory가 0인 경우에는 "Import Table" Directory를 이용하는 추가적인 루틴 필요.




## 2. Gdb
### 2.1 설치 및 환경
#### 2.1.1 기본 환경
- Gdb가 설치되어 있어야 한다. 참고로 gdb는 주어진 실행 파일이 x86인지 x64인지에 따라 자동으로 인식하므로 gdb에 관한 설정은 필요 없지만 사용하는 파이썬 파일을 거기에 맞게 사용해야 한다.
- 파이썬은 기본으로 설치된 버전2를 사용했다. 하지만 일반적으로 Tkinter는 설치되어있지 않을 때가 있는데 yum install tkinter 명령어를 사용해 설치한다.

#### 2.1.2 사용
  셸에서 해당 파이썬 스크립트를 실행하며 인자로 실행 파일을 준다.
- $ python gdb_x86.py hello
- $ python gdb_x64.py hello


### 2.2 기능
#### 2.2.1 기본 기능
  스크린샷과 비슷하게 왼쪽 윈도우에서 레지스터, 디스어셈블리, 스택을 보여주며 커맨드 라인 방식을 사용한다. 오른쪽 윈도우는 명령어의 결과를 보여준다. 그리고 아랫 부분은 디스어셈블리 창에서 보여지는 함수가 보여진다. 이것을 클릭하면 man 3 페이지를 통해 해당 함수에 대한 정보를 볼 수 있다.<br>
  레지스터 패널의 경우 아직 해당 값까지만 보여준다. 디스어셈블리 패널의 경우 뒤에서 후술할 자체 명령어에서 사용될 라인 번호가 있다. 스택의 경우 아직 기본적인 심볼 정보(x/a $sp)만을 보여준다. 마지막으로 이전 명령어를 또 실행할 때에는 그냥 엔터를 입력하면 된다.

#### 2.2.2 자체 명령어
- ,b [ 라인 번호 ] : 인자로 직접 주소를 입력할 필요 없이 해당 라인 번호를 받아서 bp를 설정할 수 있다.
- ,wt [ 라인 번호 ] : 인자로 직접 주소를 입력할 필요 없이 해당 라인 번호를 받아서 거기까지 실행시켜 준다. bp와 c 명령어의 조합이다.
- ,api [ 함수 이름 ] : 함수 이름을 직접 클릭한 것처럼 인자로 함수 이름을 받아서 해당 man 3 페이지를 보여준다.
- ,v : 왼쪽 윈도우 업데이트. ip 레지스터 수정 또는 변경 사항 발생 시 왼쪽 윈도우를 업데이트 해준다.
- ,c : 오른쪽 명령어 패널을 clear한다.
- ,vs <address> | ,vs u | ,vs d : 인자로 주소를 넣은 경우 왼쪽 윈도우를 그 주소에 맞게 보여준다. u와 d를 인자로 넣은 경우 각각 윗 페이지 그리고 아래 페이지를 보여준다.


### 2.3 To do
#### 공통
- 실행 중인 프로세스 Attach 기능 추가
- 커널 디버깅 기능 추가
- scanf 같이 입력을 받는 기능도 추가한다.
- 윈도우의 경우 winpexpect가 너무 느리기 때문에 COM을 이용한 방식을 알아보도록 한다. 리눅스의 경우 pexpect 나쁘지 않지만 더 편하게 파이썬 용 API가 제공되므로 이것을 이용한다.

#### 개별
- 더 기능을 추가한 후 .gdbinit에 정리할 부분은 정리한다.
- find와 set이 너무 불편하므로 각각 PEDA의 searchmem, patch 기능을 보고 개선한다.
- 큰 의미가 있을지 모르겠지만 x/s 명령어를 통해 스택과 레지스터에 문자열 기능을 추가한다.




## 3. Picture
- Windbg의 경우 스크립트와 플러그인을 통해, Gdb의 define 외의 여러 기능들을 찾아서 추가적인 내용들을 만들 필요가 있다. 또한 Gdb가 Windbg와 비교해서도 너무 불편하기 때문에 PEDA, GEF 등을 참고해 기본적인 기능을 보충할 필요가 있다.
- 디스어셈블리 결과를 따로 저장하고 사용하는 OllyDbg처럼 디스어셈블러와 디버거의 중간 형태를 띄어야 할지에 대한 생각. 하지만 디스어셈블러도 생각 중이므로 이쪽 기능에 너무 집착하지 않고 디버거에 충실하려고 한다.




## 4. 기타
#### 스크린샷
![start](http://cfile29.uf.tistory.com/image/997627335A141587224B8D)

#### 참고1 ] 윈도우에서 API 정보 검색
  이 방식은 HlpViewer.exe를 이용해서 로컬에 저장된 도움말 문서들을 검색하는 방식이다. API 정보들이 들어있는 문서가 로컬에 저장되어 있다면 커맨드 라인에서 HlpViewer.exe를 여러 인자들과 함께 입력하여 해당 페이지를 보여주는 메커니즘이다.<br>
  개인적으로 Visual Studio 2015를 사용하는데 HlpViewer.exe가 이미 설치되어 있었다. 이제 도움말 문서들을 로컬에 설치하는 방식을 설명하겠다. 위의 "도움말" 탭을 누른 후 "도움말 콘텐츠 추가 및 제거"를 클릭한다. 디폴트로 "콘텐츠 관리" 탭이 보일 것이다. 본인의 경우 여러 목록이 보였고 몇 개는 "추가(보류 중)"인 것도 존재했다. 이것들을 모두 취소한 후 다음 하나만 "추가"를 클릭한다.<br>
 > "Windows Desktop App Development"<br>

  설치 시 324MB의 크기였으며 이것만 선택한 이후 오른쪽 아래의 "업데이트" 버튼을 클릭한다. 이제 윈도우 API 도움말 문서가 로컬에 설치되었다.<br>
  실제 예제를 다뤄보도록 하겠다. 아래를 보면 먼저 HlpViewer.exe를 경로와 함께 실행한다.<br>
 > C:\"Program Files (x86)"\"Microsoft Help Viewer"\v2.2\HlpViewer.exe /catalogName VisualStudio14 /helpQuery "method=f1&query=securezeromemory"<br>

  첫 번쨰 인자는 다음과 같다. 이 인자는 필수로서 현재 Visual Studio 2015를 사용하기 때문에 설정한 것이다.
 > /catalogName VisualStudio14<br>

  다음은 해당 도움말 뷰어만을 켜는 것이 아니라 자동으로 특정 API 이름을 검색한 후 결과까지 보여주도록 인자를 설정한 것이다.
 > /helpQuery "method=f1&query=securezeromemory"<br>

  위에서는 SecureZeroMemory라는 API에 대한 정보를 얻기 위해 사용한 것이고 이제 저 부분에 다른 이름을 넣음으로써 자동으로 결과를 보여주게 만들 수 있다.<br>

  마지막으로 Windbg에서는 .shell 명령어를 통해 셸 명령을 실행할 수 있다. 참고로 인자 -x는 실행 이후 디버거에서 detach하는 명령이다. 그러므로 다음과 같이 사용할 수 있다.<br>

 > 0:000> .shell -x C:\"Program Files (x86)"\"Microsoft Help Viewer"\v2.2\HlpViewer.exe /catalogName VisualStudio14 /helpQuery "method=f1&query=securezeromemory" <br>
 > 0:000> 
